/**
 * Teste do Novo Sistema ZK Independente
 * 
 * Este arquivo testa a geraÃ§Ã£o de provas ZK usando os artifacts gerados pela API
 * e submissÃ£o para ZKVerify, independente do sistema atual.
 */

import { APIZKService } from './generated/example-usage';

// Import ZKVerify
import { zkVerifySession } from 'zkverifyjs';

class NewZKSystemTest {
  private zkService: APIZKService;
  private userAddress: string = '';

  constructor() {
    this.zkService = new APIZKService('credit_score');
  }

  /**
   * Teste completo do novo sistema ZK
   */
  async runCompleteTest(): Promise<{ success: boolean; txHash?: string; error?: string }> {
    console.log('ğŸš€ Starting independent new ZK system test...');
    console.warn('â„¹ï¸  Note: Analytics SDK warnings are expected in development mode and do not affect functionality');
    
    try {
      // 1. Load artifacts
      await this.loadArtifacts();
      
      // 2. Initialize ZKVerify
      await this.initializeZKVerify();
      
      // 3. Generate ZK proof
      const { proof, publicSignals } = await this.generateZKProof();
      
      // 4. Submit to ZKVerify
      const txHash = await this.submitToZKVerify(proof, publicSignals);
      
      console.log('âœ… New ZK system test completed successfully!');
      console.log('ğŸ”— TX Hash:', txHash);
      
      return { success: true, txHash };
      
    } catch (error) {
      console.error('âŒ Error in new ZK system test:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }

  /**
   * Load artifacts generated by API
   */
  private async loadArtifacts(): Promise<void> {
    console.log('ğŸ“¦ Loading artifacts generated by API...');
    
    try {
      await this.zkService.loadArtifacts();
      console.log('âœ… Artifacts loaded successfully!');
    } catch (error) {
      console.error('âŒ Error loading artifacts:', error);
      throw error;
    }
  }

  /**
   * Initialize ZKVerify session
   */
  private async initializeZKVerify(): Promise<void> {
    console.log('ğŸ” Initializing ZKVerify session...');
    
    try {
      // Enable Subwallet extension
      const { web3Enable, web3Accounts } = await import('@polkadot/extension-dapp');
      
      const extensions = await web3Enable('ZKFinance Test');
      console.log('ğŸ“± Extensions enabled:', extensions.map(ext => ext.name));
      
      if (extensions.length === 0) {
        throw new Error('No wallet extension found');
      }
      
      // Get accounts
      const accounts = await web3Accounts();
      console.log('ğŸ‘¤ Available accounts:', accounts.map(acc => acc.address));
      
      if (accounts.length === 0) {
        throw new Error('No accounts found');
      }
      
      this.userAddress = accounts[0].address;
      console.log('ğŸ¯ Using account:', this.userAddress);
      
      // Initialize ZKVerify session
      const session = await zkVerifySession.start()
        .Volta()
        .withWallet({ 
          source: 'subwallet-js', 
          accountAddress: this.userAddress 
        });
      
      console.log('âœ… ZKVerify session initialized successfully!');
      
    } catch (error) {
      console.error('âŒ Error initializing ZKVerify:', error);
      throw error;
    }
  }

  /**
   * Generate ZK proof using API artifacts
   */
  private async generateZKProof(): Promise<{ proof: any; publicSignals: any }> {
    console.log('ğŸ§® Generating ZK proof with API artifacts...');
    
    try {
      // Input for credit_score circuit (score >= threshold)
      const input = { score: 850, threshold: 800 };
      console.log('ğŸ“Š Input:', JSON.stringify(input));
      
      // Generate proof using new system
      const { proof, publicSignals } = await this.zkService.generateProof(input);
      
      console.log('âœ… ZK proof generated successfully!');
      console.log('ğŸ”‘ Proof:', proof);
      console.log('ğŸ”‘ Proof type:', typeof proof);
      console.log('ğŸ”‘ Proof keys:', Object.keys(proof));
      console.log('ğŸ“¡ Public signals:', publicSignals);
      console.log('ğŸ“¡ Public signals type:', typeof publicSignals);
      
      return { proof, publicSignals };
      
    } catch (error) {
      console.error('âŒ Error generating ZK proof:', error);
      throw error;
    }
  }

  /**
   * Submit proof to ZKVerify
   */
  private async submitToZKVerify(proof: any, publicSignals: any): Promise<string> {
    console.log('ğŸš€ Submitting proof to ZKVerify...');
    
    try {
      // Initialize session again for submission
      const session = await zkVerifySession.start()
        .Volta()
        .withWallet({ 
          source: 'subwallet-js', 
          accountAddress: this.userAddress 
        });
      
      // Get verification key
      const vkey = await this.getVerificationKey();
      console.log('ğŸ”‘ VKey ready for submission');
      console.log('ğŸ”‘ VKey type:', typeof vkey);
      console.log('ğŸ”‘ VKey keys:', Object.keys(vkey));
      
      // Submit proof
      console.log('ğŸš€ Starting submission to ZKVerify...');
      console.warn('â„¹ï¸  Note: Analytics SDK warnings are expected in development mode and do not affect functionality');
      const { events, transactionResult } = await session
        .verify()
        .groth16({ 
          library: 'snarkjs' as any, 
          curve: 'bn128' as any
        })
        .execute({ 
          proofData: { 
            vk: vkey,
            proof, 
            publicSignals 
          }, 
          domainId: 1 
        });
      
      // Listen to events
      events.on('includedInBlock', (e: any) => console.log('ğŸ“¦ Proof included in block:', e));
      events.on('finalized', (e: any) => console.log('âœ… Proof finalized:', e));
      events.on('error', (e: any) => console.error('âŒ Proof error:', e));
      
      // Wait for transaction result
      const verification = await transactionResult;
      console.log('âœ… Verification result:', verification);
      
      const txHash = verification.txHash || 'pending';
      console.log('âœ… Proof submitted to ZKVerify successfully!');
      console.log('ğŸ”— TX Hash:', txHash);
      
      return txHash;
      
    } catch (error) {
      console.error('âŒ Error submitting proof to ZKVerify:', error);
      throw error;
    }
  }

  /**
   * Get verification key
   */
  private async getVerificationKey(): Promise<any> {
    try {
      const vkeyBase64 = await import('./generated/credit_score-vkey-base64.txt?raw');
      const { base64ToUint8Array } = await import('./generated/utils');
      
      const vkeyBuffer = base64ToUint8Array(vkeyBase64.default);
      console.log('ğŸ”‘ VKey string length:', vkeyBase64.default.length);
      
      const vkey = JSON.parse(new TextDecoder().decode(vkeyBuffer));
      console.log('ğŸ”‘ VKey parsed successfully');
      
      return vkey;
      
    } catch (error) {
      console.error('âŒ Error getting verification key:', error);
      throw error;
    }
  }
}

// Run test
async function runTest() {
  const test = new NewZKSystemTest();
  
  try {
    await test.runCompleteTest();
    console.log('ğŸ‰ NEW ZK SYSTEM TEST COMPLETED SUCCESSFULLY!');
  } catch (error) {
    console.error('ğŸ’¥ NEW ZK SYSTEM TEST FAILED:', error);
  }
}

// Export for use
export { NewZKSystemTest, runTest }; 